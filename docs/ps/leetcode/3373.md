---
title: '3373 - Maximize the Number of Target Nodes After Connecting Trees II'
eng_title: '3373 - Maximize the Number of Target Nodes After Connecting Trees II'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '3373 - Maximize the Number of Target Nodes After Connecting Trees II'
sidebar_position: 3373
created_date: 2025-05-29
---

# 3373 - Maximize the Number of Target Nodes After Connecting Trees II

:::info

- **ë¬¸ì œ ë³´ê¸°**: [3373 - Maximize the Number of Target Nodes After Connecting Trees II](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii)
- **ì†Œìš” ì‹œê°„**: 30ë¶„ 10ì´ˆ
- **í’€ì´ ì–¸ì–´**: `java`
- **ì²´ê° ë‚œì´ë„**: 3ï¸âƒ£
- **ë¦¬ë·° íšŸìˆ˜**: âœ…

:::

<br />

### í’€ì´ í‚¤ì›Œë“œ

<details>
<summary>ìŠ¤í¬ì£¼ì˜</summary>

`dfs`

</details>

<br />

### í’€ì´ ì½”ë“œ

:::info

- **ë©”ëª¨ë¦¬**: 106600 KB
- **ì‹œê°„**: 114 ms

:::

```java
class Solution {
    List<Integer>[] adj1, adj2;
    boolean[] vis;
    int n, m;
    int[] cache1; // tree1 node group per ndx

    public int dfs(int ndx, int depth, int mxDepth, int parity) {
        if (depth > mxDepth) return 0;

        int res = (depth & 1) == parity ? 1 : 0;
        if (parity == 0) cache1[ndx] = depth & 1; // mark tree1 node group
        List<Integer>[] adj = parity == 0 ? adj1 : adj2;
        for (int nxt : adj[ndx]) {
            vis[ndx] = true;
            if (!vis[nxt]) res += dfs(nxt, depth+1, mxDepth, parity);
            vis[ndx] = false;
        }

        return res;
    }

    public int[] maxTargetNodes(int[][] edges1, int[][] edges2) {
        this.n = edges1.length + 1;
        this.m = edges2.length + 1;

        // init vis
        vis = new boolean[n < m ? m : n];

        // init adj
        adj1 = new ArrayList[n];
        adj2 = new ArrayList[m];
        for (int i = 0; i < n; ++i) adj1[i] = new ArrayList<>();
        for (int j = 0; j < m; ++j) adj2[j] = new ArrayList<>();
        for (int[] e : edges1) {
            adj1[e[0]].add(e[1]);
            adj1[e[1]].add(e[0]);
        }
        for (int[] e : edges2) {
            adj2[e[0]].add(e[1]);
            adj2[e[1]].add(e[0]);
        }

        // precalc: get max from tree2
        int cand = dfs(edges2[0][0], 0, m, 1); // parity: odd
        int mx = Math.max(cand, m-cand);
        
        // precalc: get max per group from tree1
        cache1 = new int[n];
        int groupVal0 = dfs(edges1[0][0], 0, n, 0); // parity: even
        int groupVal1 = n - groupVal0;

        int[] ans = new int[n];
        for (int i = 0; i < n; ++i)
            ans[i] = (cache1[i] == 0 ? groupVal0 : groupVal1) + mx;
        
        return ans;
    }
}
```

<br />

### í’€ì´ í•´ì„¤

[3372ë²ˆ](https://til.qriosity.dev/featured/ps/leetcode/3372)ì˜ í›„ì† ë¬¸ì œì´ë‹¤.

ë²”ìœ„ê°€ $2 \le n, m \le 10^5$ ì´ê¸° ë•Œë¬¸ì— dfs í˜¸ì¶œ íšŸìˆ˜ì— ìœ ì˜í•´ì•¼ í•œë‹¤. (ì´ì „ ë¬¸ì œëŠ” $10^3$ì´ì—ˆìŒ)

<br />

#### ë°œìƒì€ ì´ì „ ë¬¸ì œì™€ ë¹„ìŠ·..

ì´ì „ ë¬¸ì œì—ì„  tree1ì—ì„œ k ê±°ë¦¬, tree2ì—ì„œ k-1 ê±°ë¦¬ë¡œ ê¸°ì¤€ì¡ì•„ ë‹µì„ êµ¬í–ˆë‹¤.

ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œ, ì´ ë¬¸ì œì—ì„  tree1ì—ì„œ ì§ìˆ˜ ê±°ë¦¬, tree2ì—ì„œ í™€ìˆ˜ ê±°ë¦¬ë¡œ ê¸°ì¤€ì¡ìœ¼ë©´ ëœë‹¤.

<br />

#### ğŸ¤” ..í•˜ì§€ë§Œ ì•½ê°„ì˜ í•¨ì •ì´ ìˆìŒ

íŠ¸ë¦¬ëŠ” ëª¨ë“  ë…¸ë“œê°€ ì—°ê²°ë˜ì–´ìˆê³ , ë”°ë¼ì„œ ì–´ëŠ í•œ ë…¸ë“œë¥¼ ì •í–ˆì„ë•Œ ì§ìˆ˜/í™€ìˆ˜ ê±°ë¦¬ê°€ ë˜ëŠ” ë…¸ë“œë“¤ì€ ì¼ì¢…ì˜ ê·¸ë£¹ìœ¼ë¡œ í™•ì •ëœë‹¤.

ì˜ˆë¥¼ ë“¤ì–´ 0 - 1 - 2 - 3 - 4 í˜•ì‹ì˜ íŠ¸ë¦¬ê°€ ìˆì„ ë•Œ, 0ë²ˆ ë…¸ë“œì˜ ì§ìˆ˜/í™€ìˆ˜ ê·¸ë£¹ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.

```
ì§ìˆ˜ ê·¸ë£¹: 0, 2, 4 -> ë…¸ë“œ ê°œìˆ˜: 3
í™€ìˆ˜ ê·¸ë£¹: 1, 3 -> ë…¸ë“œ ê°œìˆ˜: 2
```

ì—¬ê¸°ì„œ ì§ìˆ˜ ê·¸ë£¹ì˜ ë…¸ë“œ ê°œìˆ˜ë¥¼ dfs í˜¸ì¶œë¡œ êµ¬í•˜ê³ , í™€ìˆ˜ ê·¸ë£¹ì€ dfs í˜¸ì¶œ ì—†ì´ ì „ì²´ ë…¸ë“œ ìˆ˜ì—ì„œ ì§ìˆ˜ ê·¸ë£¹ ë…¸ë“œ ìˆ˜ë§Œí¼ ì°¨ê°í•˜ë©´ ëœë‹¤.

<br />

#### ì½”ë“œ ì„¤ëª…

```java
int cand = dfs(edges2[0][0], 0, m, 1); // parity: odd
int mx = Math.max(cand, m-cand);
```

tree2ì—ì„  `edges2`ì— ë“¤ì–´ìˆëŠ” ë§¨ ì²« ë…¸ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì§/í™€ ê·¸ë£¹ì„ ë‚˜ëˆˆë‹¤.

ì‚¬ì‹¤ ì§/í™€ì´ë¼ëŠ” í‘œí˜„ì€ ì–´ëŠ íŠ¹ì • ë…¸ë“œë¥¼ ê¸°ì¤€ì¡ì•˜ì„ë•Œ ì–˜ê¸°ê³ , ê·¸ëƒ¥ ê·¸ë£¹1 / ê·¸ë£¹2 ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

ì—°ê²°í•  tree2ì˜ ë…¸ë“œëŠ” ììœ ë¡­ê²Œ ì„ íƒí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ë‘ ê·¸ë£¹ ì¤‘ ë” í° ì¹´ìš´íŒ… ê°’ì„ `mx`ë¡œ ì €ì¥í•´ë†“ëŠ”ë‹¤.

<br />

```java
public int dfs(int ndx, int depth, int mxDepth, int parity) {
    ...
    if (parity == 0) cache1[ndx] = depth & 1; // mark tree1 node group
```

```java
cache1 = new int[n];
int groupVal0 = dfs(edges1[0][0], 0, n, 0); // parity: even
int groupVal1 = n - groupVal0;

int[] ans = new int[n];
for (int i = 0; i < n; ++i)
    ans[i] = (cache1[i] == 0 ? groupVal0 : groupVal1) + mx;
```

tree1ì€ cache1ì´ë¼ëŠ” ìºì‹œ ë°°ì—´ì„ ë§Œë“¤ì–´ë†“ê³ , dfsë¥¼ ëŒë¦´ë•Œ ë…¸ë“œë³„ë¡œ ê·¸ë£¹ ë²ˆí˜¸ë¥¼ ë§ˆí‚¹í•´ë†“ëŠ”ë‹¤.

ê·¸ë¦¬ê³  dfs í˜¸ì¶œì´ ëë‚¬ì„ ë•Œ ë°˜í™˜ë˜ëŠ” ì¹´ìš´íŒ… ê°’ìœ¼ë¡œ ê° ê·¸ë£¹ì˜ ë…¸ë“œ ìˆ˜ë¥¼ `groupVal0`, `groupVal1`ë¡œ ì €ì¥í•˜ê³ ,

ë…¸ë“œë¥¼ ìˆœíšŒí• ë•Œ í•´ë‹¹ ë…¸ë“œì˜ ê·¸ë£¹ì— ë”°ë¼ ë§ëŠ” ì¹´ìš´íŒ… ê°’ì„ ê°€ì ¸ë‹¤ ì“°ë©´ ëœë‹¤.

<br />

### ë©”ëª¨

- dfs íŒŒë¼ë¯¸í„° ë§ì•„ì§„ ì´ìœ : dfs1, dfs2 ì•ˆ ë‚˜ëˆ„ê³  ì¬ì‚¬ìš©í•˜ë ¤ë‹¤ë³´ë‹ˆ ê·¸ë ‡ê²Œ ë¨
- ê° íŠ¸ë¦¬ë‹¹ dfs 1ë²ˆ ë„˜ê²Œ ëŒë¦¬ë©´ ë¬´ì¡°ê±´ TLEê°€ í„°ì§€ë„ë¡ ì„¤ê³„ë˜ì–´ìˆë‹¤.
- hard ë‚œì´ë„ë¼ëŠ”ë°, ì‹œë¦¬ì¦ˆì˜ ì´ì „ ë¬¸ì œì— ë¹„í•´ ì‹œê°„ë³µì¡ë„ê°€ ë” ê¹Œë‹¤ë¡œì›Œì¡Œê¸´ í•˜ì§€ë§Œ í—ˆìˆ˜ì— ê°€ê¹ë‹¤.