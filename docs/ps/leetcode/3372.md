---
title: '3372 - Maximize the Number of Target Nodes After Connecting Trees I'
eng_title: '3372 - Maximize the Number of Target Nodes After Connecting Trees I'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '3372 - Maximize the Number of Target Nodes After Connecting Trees I'
sidebar_position: 3372
created_date: 2025-05-28
updated_date: 2025-08-13
---

# 3372 - Maximize the Number of Target Nodes After Connecting Trees I

:::info

- **ë¬¸ì œ ë³´ê¸°**: [3372 - Maximize the Number of Target Nodes After Connecting Trees I](https://leetcode.com/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i)
- **ì†Œìš” ì‹œê°„**: 46ë¶„ 26ì´ˆ
- **í’€ì´ ì–¸ì–´**: `java`
- **ì²´ê° ë‚œì´ë„**: 3ï¸âƒ£
- **ë¦¬ë·° íšŸìˆ˜**: âœ…

:::

<br />

### í’€ì´ í‚¤ì›Œë“œ

<details>
<summary>ìŠ¤í¬ì£¼ì˜</summary>

`dfs`

</details>

<br />

### í’€ì´ ì½”ë“œ

:::info

- **ë©”ëª¨ë¦¬**: 46760 KB
- **ì‹œê°„**: 279 ms

:::

```java
class Solution {
    List<Integer>[] adj1, adj2;
    boolean[] vis1, vis2;
    int n, m, k;

    public int dfs1(int i, int depth) { // tree 1
        if (depth > k) return 0;

        int res = 1;
        for (int nxt : adj1[i]) {
            vis1[i] = true;
            if (!vis1[nxt]) res += dfs1(nxt, depth+1);
            vis1[i] = false;
        }

        return res;
    }

    public int dfs2(int j, int depth) { // tree 2
        if (depth > k-1) return 0;

        int res = 1;
        for (int nxt : adj2[j]) {
            vis2[j] = true;
            if (!vis2[nxt]) res += dfs2(nxt, depth+1);
            vis2[j] = false;
        }

        return res;
    }

    public int[] maxTargetNodes(int[][] edges1, int[][] edges2, int k) {
        this.n = edges1.length + 1;
        this.m = edges2.length + 1;
        this.k = k;

        // init adj
        this.adj1 = new ArrayList[n];
        this.adj2 = new ArrayList[m];
        for (int i = 0; i < n; ++i) adj1[i] = new ArrayList<>();
        for (int j = 0; j < m; ++j) adj2[j] = new ArrayList<>();
        for (int[] e : edges1) {
            adj1[e[0]].add(e[1]);
            adj1[e[1]].add(e[0]);
        }
        for (int[] e : edges2) {
            adj2[e[0]].add(e[1]);
            adj2[e[1]].add(e[0]);
        }

        // init visited
        vis1 = new boolean[n];
        vis2 = new boolean[m];

        // dfs
        int[] ans = new int[n];
        int mx = 0; // get maximum tree 2 nodes of distance k
        for (int j = 0; j < m; ++j)
            mx = Math.max(mx, dfs2(j, 0));
        
        for (int i = 0; i < n; ++i) {
            // count tree 1 nodes of distance k
            ans[i] = dfs1(i, 0) + mx;
        }

        return ans;
    }
}
```

<br />

### í’€ì´ í•´ì„¤

tree1ì˜ íŠ¹ì • ë…¸ë“œ ië¥¼ tree2ì˜ ë…¸ë“œì— ì—°ê²°í–ˆì„ ë•Œ, ië¡œë¶€í„°ì˜ ê±°ë¦¬ê°€ k ì´í•˜ì¸ ìµœëŒ€ ë…¸ë“œ ìˆ˜ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì´ë‹¤.

ì •í™•íˆëŠ” tree1ì˜ ëª¨ë“  ë…¸ë“œì— ëŒ€í•˜ì—¬ êµ¬í•´ì•¼ë˜ê¸° ë•Œë¬¸ì— ë°˜í™˜í˜•ì´ `int`ê°€ ì•„ë‹ˆê³  `int[]`ì´ë‹¤.

ì§€ë¬¸ì´ ì¢€ ë‚œë…ì¦ ì˜¤ëŠ”ë° ëŒ“ê¸€ì—ì„œ ì‚¬ëŒë“¤ì´ ë‚¨ê¸´ ì„¤ëª…ì„ ì½ì–´ë³´ë©´ ê·¸ì œì„œì•¼ ì´í•´ëœë‹¤.

<br />

> By maximum possible number of nodes target to node i of the first tree, it means how many nodes are less than k edges away from node i of the first tree.
>
> For Example 1:
> edges1 = [[0,1],[0,2],[2,3],[2,4]], edges2 = [[0,1],[0,2],[0,3],[2,7],[1,4],[4,5],[4,6]], k = 2
>
> For i = 0, connect node 0 from the first tree to node 0 from the second tree.
>
> If there is an edge from node 0 of tree1 and node 0 of tree2<br />
> Here are the nodes k edges away to node 0 of tree1:<br />
> from tree1: [0,1,2,3,4]<br />
> from tree2: [0,2,3,1]<br />
> For a total of 9 nodes

<br />

#### ğŸ˜® tree2 dfsëŠ” í•œë²ˆë§Œ ëŒë ¤...

tree1ì˜ ëª¨ë“  ë…¸ë“œì— ëŒ€í•´ êµ¬í•˜ë¼ê³  ë˜ì–´ìˆì–´ì„œ tree1ì˜ ëª¨ë“  ë…¸ë“œ($i: [0, n)$)ì— ëŒ€í•œ ìˆœíšŒ ë¡œì§ì´ ìµœì™¸ê°ì— ìˆì—ˆê³ 

ì´ ìˆœíšŒ ë¡œì§ ë‚´ë¶€ì—ì„œ tree2ì— ëŒ€í•œ dfs2ë¥¼ í˜¸ì¶œí•˜ëŠ” ì‹¤ìˆ˜ë¥¼ í–ˆëŠ”ë°, ë‹¹ì—°íˆ TLE í„°ì¡Œë‹¤.

ìƒê°í•´ë³´ë‹ˆ dfs2ëŠ” tree2ì—ì„œì˜ max ê°’ ì°¾ëŠ” ëª©ì ìœ¼ë¡œ ëŒë¦¬ëŠ” ê²ƒì´ë¼, 0 ~ m-1 ë…¸ë“œê¹Œì§€ í•œë²ˆ ëŒë ¤ë†“ìœ¼ë©´ ëì´ë‹¤.

ì´í›„ëŠ” ê·¸ëƒ¥ ê° ë…¸ë“œ i ë³„ë¡œ max ê°’ë§Œ í•©í•´ì„œ ì •ë‹µ ë°°ì—´ì— ë„£ì–´ì£¼ë©´ ë˜ê¸° ë•Œë¬¸ì´ë‹¤.

ê·¸ë˜ì„œ dfs1 ëŒë¦¬ê¸° ì „ì— ë¨¼ì € ìˆ˜í–‰í•˜ëŠ” ê²ƒìœ¼ë¡œ ìˆ˜ì •í–ˆë‹¤.

<br />

#### ğŸš« ë¬´ì§€ì„± base case ì‘ì„± ê¸ˆì§€

```java title="WA1"
public int dfs2(int j, int depth) { // tree 2
    if (depth == k-1) return 1;
```
```java title="WA2"
public int dfs2(int j, int depth) { // tree 2
    if (depth >= k-1) return 1;
```

ì›ë˜ëŠ” ìƒë‹¨ê³¼ ê°™ì€ EQ, GTEë¡œ ê¸°ì € ì¡°ê±´ì„ ì‘ì„±í–ˆëŠ”ë° ë‹¤ WA ë°›ì•˜ë‹¤.

WAê°€ ëœ¨ëŠ” TCëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

```
[[0,1]]
[[0,1]]
0
```
```
Expected: [1,1]
```

WAë¥¼ ë°›ì€ ì´ìœ ëŠ” kê°€ 0ì¼ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

> - 0 &lt;= k &lt;= 1000

<p style={{fontSize: '48px'}}><b>ë¬¸ì œë¥¼ ì˜ ì½ì</b></p>

`depth == -1` ëŠ” ê¸°ì € ì¡°ê±´ì´ ì‘ë™ì„ ì•ˆí•˜ê³ 

`depth >= -1` ì€ ì‘ë™í•˜ì§€ë§Œ `return 1`ì„ í•˜ë¯€ë¡œ í‹€ë ¸ë‹¤. ì• ì´ˆì— ì‹œì‘ë¶€í„° ê±°ë¦¬ ì´ˆê³¼ë¼ì„œ ë…¸ë“œ jë¥¼ ì¹´ìš´íŒ…í•˜ë©´ ì•ˆë˜ê¸° ë•Œë¬¸ì´ë‹¤.

```java title="AC"
public int dfs2(int j, int depth) { // tree 2
    if (depth > k-1) return 0;
```

ë”°ë¼ì„œ **ê±°ë¦¬ê°€ ì´ˆê³¼ë˜ì—ˆì„ ë•Œ 0ì„ ë¦¬í„´**í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ ì˜³ë‹¤.

<br />

### âœ¨ ë²ˆì™¸: TC ì‹œê°í™”í•˜ê¸°

811ë²ˆ íš¨ìœ¨ì„± ì €ê²©ìš© í…ŒìŠ¤íŠ¸ì¼€ì´ìŠ¤ë¥¼ íŒŒì´ì¬ìœ¼ë¡œ ì‹œê°í™”í•´ë³´ì•˜ë‹¤.

ì½”ë“œê°€ ê°€ì„±ë¹„ë¡œ ë§›ìˆìŒã…‹ã…‹ã…‹

```py
import networkx as nx
import matplotlib.pyplot as plt

edges1 = [[257,1],[340,3],[454,5],[847,6],[701,10],[436,11],[710,16],[14,17],[495,14],[259,20],[858,21],[849,28],[733,30],[780,35],[304,43],[567,46],[851,47],[409,48],[606,52],[466,54],[78,57],[18,58],[537,62],[786,65],[482,69],[770,70],[132,71],[31,72],[183,31],[699,73],[27,74],[7,77],[157,78],[97,82],[744,83],[812,84],[496,88],[504,92],[600,93],[153,94],[714,96],[299,98],[139,99],[296,101],[441,103],[784,104],[283,105],[39,109],[670,110],[391,114],[435,115],[90,116],[435,118],[317,124],[725,125],[209,126],[134,127],[681,130],[59,131],[209,132],[227,137],[36,139],[444,144],[319,145],[341,147],[141,149],[819,155],[203,156],[87,159],[795,87],[79,168],[750,174],[468,175],[409,177],[310,179],[690,180],[658,181],[292,182],[722,183],[426,186],[321,187],[258,188],[646,192],[148,195],[97,200],[472,97],[277,203],[257,204],[595,206],[59,208],[568,59],[306,211],[36,217],[517,36],[18,220],[292,222],[251,223],[44,225],[198,44],[569,198],[651,229],[407,231],[7,232],[113,233],[112,236],[13,239],[774,244],[527,245],[697,246],[768,247],[828,251],[237,253],[769,237],[475,254],[604,256],[573,258],[846,263],[407,267],[378,272],[13,278],[637,279],[45,280],[347,282],[294,288],[597,290],[768,292],[573,295],[815,296],[75,301],[431,75],[360,303],[530,306],[609,308],[444,310],[330,314],[51,318],[283,319],[716,324],[829,329],[294,331],[150,294],[162,333],[298,336],[729,298],[261,340],[800,261],[413,342],[735,345],[215,346],[459,215],[432,349],[506,351],[719,352],[563,357],[341,360],[720,363],[844,364],[644,366],[471,367],[559,372],[228,373],[634,228],[496,374],[670,376],[723,378],[509,379],[270,384],[640,270],[285,385],[334,285],[230,387],[572,390],[154,394],[100,154],[542,100],[795,396],[135,397],[547,135],[240,399],[320,240],[45,401],[783,45],[120,403],[447,120],[835,411],[219,412],[571,413],[639,414],[698,415],[767,420],[485,422],[434,423],[647,425],[128,430],[710,431],[242,433],[350,435],[671,350],[497,436],[300,438],[753,442],[37,443],[520,37],[493,446],[106,447],[459,448],[34,450],[453,34],[128,453],[210,128],[347,454],[375,347],[328,457],[441,459],[514,460],[209,461],[816,209],[7,462],[445,7],[238,463],[51,464],[317,51],[798,465],[249,469],[771,471],[382,472],[482,474],[577,478],[164,479],[391,164],[334,480],[171,481],[793,485],[714,487],[289,488],[632,490],[23,492],[138,23],[539,494],[238,499],[737,238]]
edges2 = [[645,0],[690,1],[612,4],[561,8],[111,11],[646,12],[718,13],[747,14],[10,16],[546,20],[109,21],[143,27],[408,31],[278,34],[674,35],[453,38],[28,46],[355,47],[596,48],[559,50],[39,51],[368,53],[83,56],[642,61],[446,62],[191,64],[435,65],[155,67],[723,69],[166,76],[415,80],[673,85],[528,87],[25,90],[97,25],[691,96],[282,97],[681,98],[338,99],[518,104],[108,105],[411,107],[313,109],[699,112],[111,118],[416,120],[45,121],[334,123],[722,132],[704,140],[163,142],[333,144],[552,145],[470,147],[266,149],[698,150],[348,154],[641,157],[384,158],[88,162],[340,163],[182,166],[233,169],[184,171],[70,173],[83,70],[405,83],[517,174],[280,178],[302,180],[381,181],[720,183],[317,187],[602,191],[453,192],[282,193],[117,195],[718,196],[651,198],[82,200],[271,203],[754,204],[359,206],[398,211],[654,214],[86,216],[254,86],[202,221],[631,202],[141,223],[289,141],[15,224],[352,226],[630,234],[284,236],[448,237],[542,240],[201,241],[372,201],[495,245],[408,246],[382,247],[371,248],[529,252],[525,257],[422,259],[42,261],[100,42],[750,263],[253,264],[40,253],[190,40],[379,190],[306,266],[469,271],[45,273],[477,277],[332,279],[320,280],[512,283],[146,284],[289,285],[127,289],[418,127]]

# Combine all edges
all_edges = edges1 + edges2

# Create a graph
G = nx.Graph()
G.add_edges_from(all_edges)

# Draw the graph
plt.figure(figsize=(16, 14))
pos = nx.spring_layout(G, k=0.15)

node_colors = ['pink' if node == 0 else 'skyblue' for node in G.nodes()]
nx.draw_networkx_nodes(G, pos, node_size=50, node_color=node_colors)
nx.draw_networkx_labels(G, pos, font_size=8)

nx.draw_networkx_edges(G, pos, alpha=0.3)

plt.title("Graph Representation from Combined Edge Lists", fontsize=20)
plt.axis("off")
plt.show()
```

![https://velog.velcdn.com/images/qriosity/post/7727006f-85d4-46bd-aaf5-8d3032ba5204/image.png](https://velog.velcdn.com/images/qriosity/post/7727006f-85d4-46bd-aaf5-8d3032ba5204/image.png)

### ë©”ëª¨

- êµ¬í˜„ì€ ì‰¬ìš´ë°, ë¬¸ì œë¥¼ í•„ìš” ì´ìƒìœ¼ë¡œ ì–´ë µê²Œ í•´ì„í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜
    - ë‹¨ìˆœíˆ dfs ë‘ ê°œ ì“°ë©´ ë˜ëŠ”ê±¸ ë˜ ì´ìƒí•œ DP ì˜ì‹¬í•˜ê³  ìˆì—ˆìŒ ã…œ