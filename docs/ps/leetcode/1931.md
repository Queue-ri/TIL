---
title: '1931 - Painting a Grid With Three Different Colors'
eng_title: '1931 - Painting a Grid With Three Different Colors'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '1931 - Painting a Grid With Three Different Colors'
sidebar_position: 1931
created_date: 2025-05-18
updated_date: 2025-05-19
---

# 1931 - Painting a Grid With Three Different Colors

:::info

- **ë¬¸ì œ ë³´ê¸°**: [1931 - Painting a Grid With Three Different Colors](https://leetcode.com/problems/painting-a-grid-with-three-different-colors)
- **ì†Œìš” ì‹œê°„**: ğŸ’¥**1ì‹œê°„ ì´ˆê³¼**
- **í’€ì´ ì–¸ì–´**: `java`
- **ì²´ê° ë‚œì´ë„**: 4ï¸âƒ£
- **ë¦¬ë·° íšŸìˆ˜**: âœ…

:::

<br />

### í’€ì´ í‚¤ì›Œë“œ

<details>
<summary>ìŠ¤í¬ì£¼ì˜</summary>

`DP` `ë¹„íŠ¸ë§ˆìŠ¤í‚¹` `dfs` `ì¡°í•©ë¡ `

</details>

<br />

### í’€ì´ ì½”ë“œ

:::info

- **ë©”ëª¨ë¦¬**: 55170 KB
- **ì‹œê°„**: 255 ms

:::

```java
import java.util.*;

class Solution {
    final int MOD = 1_000_000_007;
    int m;
    int n;
    List<int[]> mColList;
    List<List<Integer>> nxtColIdList; // list of mColList id list
    Map<Integer, Integer> memo;

    public long dp(int x, int prevColId) {
        if (x == n) return 1;

        int key = x << 10 | prevColId;
        if (memo.containsKey(key)) return memo.get(key);

        long res = 0L;
        for (int id : nxtColIdList.get(prevColId)) {
            res = (res + dp(x+1, id)) % MOD;
        }

        memo.put(key, (int)res);
        return res;
    }

    public int colorTheGrid(int m, int n) {
        this.m = m;
        this.n = n;
        mColList = new ArrayList<>();
        nxtColIdList = new ArrayList<>();
        memo = new HashMap<>();

        // 1. dfs: pre-compute m-length columns
        initMColList(new ArrayList<>(), 0);

        // 2. pre-compute valid adj next columns for each m-length column
        initNxtColIdList();

        // 3. calc # of ways
        long ans = 0L;
        for (int id = 0; id < mColList.size(); ++id) {
            ans = (ans + dp(1, id)) % MOD;
        }

        return (int) ans;
    }

    public void initMColList(List<Integer> data, int y) {
        if (y == m) { // base case
            int[] col = new int[m];
            for (int i = 0; i < m; ++i) col[i] = data.get(i);
            mColList.add(col);
            return;
        }

        for (int c = 0; c < 3; ++c) { // iterate RGB
            if (0 < y && data.get(y-1) == c) continue;
            data.add(c);
            initMColList(data, y+1);
            data.remove(data.size()-1);
        }
    }

    public void initNxtColIdList() {
        for (int aid = 0; aid < mColList.size(); ++aid) {
            nxtColIdList.add(aid, new ArrayList<>());
            for (int bid = 0; bid < mColList.size(); ++bid) {
                if (check(aid, bid)) {
                    nxtColIdList.get(aid).add(bid);
                }
            }
        }
    }

    // check if b can be next to a
    public boolean check(int aid, int bid) {
        int[] a = mColList.get(aid);
        int[] b = mColList.get(bid);

        for (int i = 0; i < m; ++i) {
            if (a[i] == b[i]) return false;
        }

        return true;
    }
}
```

<br />

### í’€ì´ í•´ì„¤

ë‹¨ìˆœ ë°±íŠ¸ë˜í‚¹ì€ TLE í„°ì§€ëŠ”ë° DPë¡œ ì ‘ê·¼í•˜ìë‹ˆ ë©”ëª¨ì´ì œì´ì…˜ ì ìš©í•˜ê¸° ë¹¡ì„¼ ìœ í˜•ì´ë‹¤.

ì™œëƒí•˜ë©´ ë©”ëª¨ì´ì œì´ì…˜ì„ ìœ„í•´ DP stateë¥¼ 'ì ë‹¹í•˜ê²Œ' ì •ì˜í•´ì•¼ í•˜ëŠ”ë°

í˜„ì¬ ì¹¸, ë˜ëŠ” ì¸ì ‘ ì¹¸(ìœ„ìª½, ì™¼ìª½)ì˜ ì¹ í•´ì§„ ìƒ‰ì„ state ì •ì˜ë¡œ ì‚¬ìš©í•˜ë©´ WAì´ê¸° ë•Œë¬¸ì´ë‹¤.

<br />

### âŒ ì‹¤íŒ¨í•œ ë°œìƒ

:::caution WA1

### memo[i][c] -> âŒ

> *ê° ì¹¸ì˜ ë²ˆí˜¸ë¥¼ `i`ë¡œ ì •ì˜í•  ë•Œ, í•´ë‹¹ ì¹¸ì— ìƒ‰ì¹ ëœ ìƒ‰ì„ `c`ë¼ê³  í•˜ì.*

íŠ¹ì • ì¹¸ì— ì¹ í•´ì§„ ìƒ‰ ë¿ë§Œ ì•„ë‹ˆë¼ ì¸ì ‘í•œ ë‹¤ë¥¸ ì¹¸ì˜ ìƒ‰ì¹  ìƒíƒœê°€ ê²½ìš°ì˜ ìˆ˜ì— ì˜í–¥ì„ ë¯¸ì¹˜ë¯€ë¡œ,

í•´ë‹¹ stateëŠ” ì˜ëª»ëœ ì •ì˜ì´ë‹¤.

:::

<br />

:::caution WA2

### memo[i][tc][lc] -> âŒ

> *ê° ì¹¸ì˜ ë²ˆí˜¸ë¥¼ `i`ë¡œ ì •ì˜í•  ë•Œ, í•´ë‹¹ ì¹¸ì˜ ìœ„ìª½ì— ì¹ í•´ì§„ ìƒ‰ì„ `tc`, ì™¼ìª½ì— ì¹ í•´ì§„ ìƒ‰ì„ `lc`ë¼ê³  í•˜ì.*

ì´ ì—­ì‹œ ë‹¤ë¥¸ ì¹¸ì—ì„œ ê²½ìš°ì˜ ìˆ˜ì— ì˜í–¥ì„ ì£¼ê¸° ë•Œë¬¸ì— ì˜ëª»ëœ state ì •ì˜ì´ë‹¤.

:::

<br />

### ğŸ˜® ê·¸ëŸ¼ ì–´ì©Œë¼ê³ ?

ê·¸ëŸ¬ë‹ˆê¹Œ, **ì¹¸ ë‹¨ìœ„ê°€ ì•„ë‹ˆë¼ í•œ ì¤„ í†µì§¸ë¡œ** ë©”ëª¨ì´ì œì´ì…˜ í•´ì•¼ í•œë‹¤.

ë”°ë¼ì„œ ì´ ë¬¸ì œëŠ” column(ì„¸ë¡œ) ë‹¨ìœ„ë¡œ ì¹ í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ê²½ìš°ë“¤ì„ pre-compute í•´ì„œ

ì´ columnë“¤ì´ ì¸ì ‘í•˜ê²Œ ë†“ì¼ ìˆ˜ ìˆëŠ” ê²½ìš°ì˜ ìˆ˜ë¥¼ xì¶• ë°©í–¥ìœ¼ë¡œ dpë¥¼ ìˆ˜í–‰í•˜ì—¬ êµ¬í•˜ëŠ” ì‹ì´ë‹¤.

ë¬¼ë¡  columnë¼ë¦¬ ì¸ì ‘í•˜ê²Œ ë†“ì¼ ìˆ˜ ìˆëŠ”ì§€ë„ pre-compute í•´ì„œ `nxtColIdList`ë¡œ ê¸°ë¡í•´ë‘”ë‹¤.

(ë§Œì•½ `n`ê³¼ `m` ë²”ìœ„ê°€ ê±°ê¾¸ë¡œ ëœë‹¤ë©´, rowë¥¼ pre-compute í•´ì„œ yì¶• ë°©í–¥ìœ¼ë¡œ dpë¥¼ ìˆ˜í–‰í•˜ë©´ ëœë‹¤.)

```java title="[DFS] pre-compute columns"
public void initMColList(List<Integer> data, int y) {
    if (y == m) { // base case
        int[] col = new int[m];
        for (int i = 0; i < m; ++i) col[i] = data.get(i);
        mColList.add(col);
        return;
    }

    for (int c = 0; c < 3; ++c) { // iterate RGB
        if (0 < y && data.get(y-1) == c) continue;
        data.add(c);
        initMColList(data, y+1);
        data.remove(data.size()-1);
    }
}
```

```java title="pre-compute valid next-columns"
public void initNxtColIdList() {
    for (int aid = 0; aid < mColList.size(); ++aid) {
        nxtColIdList.add(aid, new ArrayList<>());
        for (int bid = 0; bid < mColList.size(); ++bid) {
            if (check(aid, bid)) {
                nxtColIdList.get(aid).add(bid);
            }
        }
    }
}

// check if b can be next to a
public boolean check(int aid, int bid) {
    int[] a = mColList.get(aid);
    int[] b = mColList.get(bid);

    for (int i = 0; i < m; ++i) {
        if (a[i] == b[i]) return false;
    }

    return true;
}
```

<br />

#### ë²”ìœ„ë‘ dp ë°©í–¥ì´ë‘ ë¬´ìŠ¨ ìƒê´€?

pre-compute ë•Œë¬¸ì— **m, nì˜ ë²”ìœ„ì— ë”°ë¼ ë©”ëª¨ì´ì œì´ì…˜ ëŒ€ìƒê³¼ dp ë°©í–¥ì´ ë‹¬ë¼ì§„ë‹¤.**

ê°€ëŠ¥í•œ ê¸¸ì´ mì˜ ëª¨ë“  columnì„ êµ¬í•˜ë ¤ í•  ë•Œ, ê²½ìš°ì˜ ìˆ˜ëŠ” $3^5 = 243$ ë¯¸ë§Œì¸ë°

ë§Œì•½ mì˜ ë²”ìœ„ê°€ nì²˜ëŸ¼ $\le 1000$ ì´ì—ˆë‹¤ë©´ $3^{1000}$ ì´ ë˜ë‹ˆê¹Œ... ì²˜ë¦¬í•˜ê¸° í˜ë“¤ì–´ì§„ë‹¤.

ë”°ë¼ì„œ ë²”ìœ„ë¥¼ ë³´ê³  ëŒ€ê°• row ê¸°ì¤€ìœ¼ë¡œ í• ì§€ column ê¸°ì¤€ìœ¼ë¡œ í• ì§€ ìœ ì¶”í•  ìˆ˜ ìˆë‹¤.

<br />

### âœ¨ State Compression DP

columnì˜ ìƒ‰ì¹  ìƒíƒœë¥¼ ë‹¨ìˆœíˆ 0/1/2 ì¡°í•©ì˜ `m`ê¸€ì Stringìœ¼ë¡œ ì²˜ë¦¬í•´ì„œ

dpì˜ xì¢Œí‘œì™€ ê°™ì´ ë¬¶ì–´ í•´ì‹œë¡œ ë©”ëª¨ì´ì œì´ì…˜ ì²˜ë¦¬í•  ìˆ˜ë„ ìˆë‹¤. ğŸ‘‰ 900ms ëŒ€ ì„±ëŠ¥

<br />

í•˜ì§€ë§Œ `mColList`ì˜ ì¸ë±ìŠ¤ë¥¼ `id`ë¡œ ì¡ì•„ ì´ë¥¼ xì¢Œí‘œë‘ ê°™ì´ ë¬¶ìœ¼ë©´ 200ms ëŒ€ë¡œ ìµœì í™”ê°€ ê°€ëŠ¥í•˜ë‹¤.

$m \le 5$ ì´ë¯€ë¡œ $id < 3^5 < 2^8$

$n \le 1000$ ì´ë¯€ë¡œ $x \le 1000 < 2^{10}$ ì´ì–´ì„œ ê°™ì´ ë¬¶ì–´ë„ int ë²”ìœ„ ë‚´ë¡œ ë¹„íŠ¸ë§ˆìŠ¤í‚¹ ê°€ëŠ¥í•˜ë‹¤.

ì•„ë‹ˆë©´ ê·¸ëƒ¥ `memo[x][prevColId]`ì™€ ê°™ì´ 2ì°¨ì› ë©”ëª¨ì´ì œì´ì…˜ì„ í•˜ë“ ê°€.. ~~*ê·¼ë° [ì €ë²ˆ ë¬¸ì œ](http://til.qriosity.dev/featured/ps/leetcode/3335)ì˜ PTSDê°€*~~

```java {4}
public long dp(int x, int prevColId) {
    if (x == n) return 1;

    int key = x << 10 | prevColId;
    if (memo.containsKey(key)) return memo.get(key);
    ...
```

<br />

### ë©”ëª¨

- ì¹´ì¹´ì˜¤ ê³µì±„ ê³ ë‚œì´ë„ ì •ë„ë©´ ë‚˜ì˜¬ìˆ˜ë„
- ì´ ë¬¸ì œë„ [matrix exponentiation](https://leetcode.com/problems/painting-a-grid-with-three-different-colors/solutions/6754758/matrix-exponentiation-with-manuscript-beats-100)ìœ¼ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë‹¤.
    - í•˜ì§€ë§Œ ì‹¤ì „ì ìœ¼ë¡œëŠ” classic DP ë°©ì‹ì´ ìš°ì„ ì‹œëœë‹¤.