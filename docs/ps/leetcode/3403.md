---
title: '3403 - Find the Lexicographically Largest String From the Box I'
eng_title: '3403 - Find the Lexicographically Largest String From the Box I'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '3403 - Find the Lexicographically Largest String From the Box I'
sidebar_position: 3403
created_date: 2025-06-04
---

# 3403 - Find the Lexicographically Largest String From the Box I

:::info

- **ë¬¸ì œ ë³´ê¸°**: [3403 - Find the Lexicographically Largest String From the Box I](https://leetcode.com/problems/find-the-lexicographically-largest-string-from-the-box-i)
- **ì†Œìš” ì‹œê°„**: 25ë¶„ 49ì´ˆ
- **í’€ì´ ì–¸ì–´**: `java`
- **ì²´ê° ë‚œì´ë„**: 3ï¸âƒ£
- **ë¦¬ë·° íšŸìˆ˜**: âœ…

:::

<br />

### í’€ì´ í‚¤ì›Œë“œ

<details>
<summary>ìŠ¤í¬ì£¼ì˜</summary>

`ë¬¸ìì—´`

</details>

<br />

### í’€ì´ ì½”ë“œ

:::info

- **ë©”ëª¨ë¦¬**: 52700 KB
- **ì‹œê°„**: 10 ms

:::

```java
class Solution {
    public String answerString(String word, int numFriends) {
        if (numFriends == 1) return word; // corner case

        // lex order first, desc length order then
        final int n = word.length();
        final int mxLen = word.length() - (numFriends-1);

        Set<String> candSet = new TreeSet<>(Collections.reverseOrder());
        char mxChar = 'a';
        char[] wordArr = word.toCharArray();
        for (char ch : wordArr) mxChar = mxChar < ch ? ch : mxChar;

        for (int i = 0; i < n; ++i) {
            if (wordArr[i] != mxChar) continue;
            int j = Math.min(i+mxLen, n);
            candSet.add(word.substring(i, j));
        }
        
        return candSet.iterator().next();
    }
}
```

<br />

### í’€ì´ í•´ì„¤

ë¬¸ìì—´ì„ ì¹œêµ¬ ìˆ˜ë§Œí¼ ë¹ˆ ë¬¸ìì—´ì´ ë˜ì§€ ì•Šë„ë¡ ìª¼ê°œê³ ,

ê·¸ ë¬¸ìì—´ë“¤ ì¤‘ì—ì„œ **lexicographically largest**í•œ ë¬¸ìì—´ì„ ë°˜í™˜í•´ì•¼ í•˜ëŠ” ë¬¸ì œì´ë‹¤.

...ê¸¸ì–´ì„œ lexë¼ê³  í•˜ê² ë‹¤. lex largest stringì„ êµ¬í•˜ë ¤ë©´

1. ì‚¬ì „ìˆœìœ¼ë¡œ ë’¤ì— ìˆëŠ” ê²ƒ ìš°ì„ 
2. ë¹„êµ ê°€ëŠ¥í•œ ë²”ìœ„ì—ì„œ ë¬¸ì êµ¬ì„±ì´ ëª¨ë‘ ë™ì¼í•˜ë©´ ê¸¸ì´ê°€ ê¸´ ë¬¸ìì—´ ìš°ì„ 

ì´ 2ê°€ì§€ ê¸°ì¤€ìœ¼ë¡œ ë¬¸ìì—´ì„ í•„í„°ë§í•´ì•¼ í•œë‹¤.

ì´ëŠ” ê²°êµ­ "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa" ë³´ë‹¤ "z" ê°€ ë” lex largest í•˜ë‹¤ëŠ” ëœ»ì´ë¼ì„œ,

`mxChar`ì„ ì‚¬ì „ì— ê²°ì •í•˜ê³  í•´ë‹¹ ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” ì¸ë±ìŠ¤ì—ì„œë§Œ í›„ë³´êµ°ì„ íƒìƒ‰í•˜ë„ë¡ ê·¸ë¦¬ë””í•œ ì ‘ê·¼ ë°©ì‹ì„ ë– ì˜¬ë ¸ë‹¤.

<br />

#### ìë°”ì˜ TreeSet ì‚¬ìš©í•´ë³´ê¸°

TreeSetì€ RBTë¡œ êµ¬í˜„ëœ, 'ìë™ì •ë ¬ unique ìš°ì„ ìˆœìœ„ í' ê°™ì€ ê²ƒì´ë¼ê³  ìƒê°í•˜ë©´ ëœë‹¤.

ê·¸ëƒ¥ setì´ í•„ìš”í•œë° ì •ë ¬ë„ í•„ìš”í•˜ë‹¤ ì‹¶ìœ¼ë©´ TreeSet ì“°ë©´ ëœë‹¤.

```java
Set<String> candSet = new TreeSet<>(Collections.reverseOrder());
```

rootì— lex largestí•œ ë¬¸ìì—´ì´ ë†“ì´ë„ë¡ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ìƒì„±í–ˆê³ , `iterator().next()`ë¡œ rootì— ì ‘ê·¼í–ˆë‹¤.

TreeSetì„ ì„ íƒí•œ ì´ìœ ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

- í›„ë³´ ë¬¸ìì—´ì˜ ì¤‘ë³µì„ ì œê±°í•˜ì—¬ í›„ë³´êµ° íƒìƒ‰ì‹œ ë³µì¡ë„ë¥¼ ìµœì í™”í•  ìˆ˜ ìˆê¸° ë•Œë¬¸
- ìë™ ì •ë ¬ ì¡°ì•„ìš© ğŸ¤—ğŸ’•

<br />

:::caution

## corner case ì¡°ì‹¬ â—

```java
public String answerString(String word, int numFriends) {
    if (numFriends == 1) return word; // corner case
```

:::

```text title="í‹€ë¦¬ê¸° ì‰¬ìš´ ë°˜ë¡€"
"gh"
1
ë‹µ: "gh"
```

<br />

ìƒë‹¨ì˜ corner caseê°€ ë³„ë„ë¡œ ì²˜ë¦¬ë˜ì§€ ì•ŠëŠ”ë‹¤ë©´ ì–´ë–»ê²Œ ë¡œì§ì´ ëŒì•„ê°ˆì§€ ë¶„ì„í•´ë³´ì.

```java {1,5}
final int mxLen = word.length() - (numFriends-1);

char mxChar = 'a';
char[] wordArr = word.toCharArray();
for (char ch : wordArr) mxChar = mxChar < ch ? ch : mxChar;
```

ë³„ë‹¤ë¥¸ ì²˜ë¦¬ê°€ ì—†ì„ ì‹œ `mxLen`ì€ ì •ìƒì ìœ¼ë¡œ 2ë¡œ ì„¤ì •ë˜ì§€ë§Œ

ê·¸ë¦¬ë””í•˜ê²Œ ê°€ì¥ ì‚¬ì „ìˆœìœ¼ë¡œ ë†’ì€ ì•ŒíŒŒë²³ì„ ì¶”ë¦¬ëŠ” ê³¼ì •ì—ì„œ `mxChar`ì´ hë¡œ ì„¤ì •ë˜ê³ 

```java {3} title="ì—¬ê¸°ì„œ candSetì—” ë­ê°€ ë“¤ì–´ê°ˆê¹Œìš”?"
for (int i = 0; i < n; ++i) {
    if (wordArr[i] != mxChar) continue;
    int j = Math.min(i+mxLen, n);
    candSet.add(word.substring(i, j));
}
```

ê²°êµ­ forë¬¸ ìˆœíšŒì—ì„œ i = 0ì¼ë•Œ gë¡œ ì‹œì‘í•˜ëŠ” ë¬¸ìì—´ì€ ìŠ¤í‚µë˜ë©°

i = 1ì¼ë•Œ hë¡œ ì‹œì‘í•˜ëŠ” ë¬¸ìì—´ ì¤‘ì—ì„œ `j`ê°€ min(1+2, 2) = 2ë¡œ ì„¤ì •ë˜ì–´ "h"ê°€ `candSet`ì— ë“¤ì–´ê°€ê²Œ ëœë‹¤.

í•˜ì§€ë§Œ `numFriends`ê°€ 1ì´ì—ˆê¸°ì— ì‚¬ì‹¤ "gh"ëŠ” ìª¼ê°œì§ˆ ìˆ˜ê°€ ì—†ì—ˆë‹¤ (!)

ì™„ì „íˆ ì˜ˆì™¸ ì¼€ì´ìŠ¤ì¸ ê²ƒì´ë‹¤.

<br />

### âœ¨ ë‹¤ë¥¸ í’€ì´ ë°©ë²•

`TreeSet`ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  `compareTo` ë©”ì†Œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë” ë‚˜ì€ ë¬¸ìì—´ ë°œê²¬ì‹œ ê·¸ë•Œê·¸ë•Œ ë°”ê¿”ì£¼ë©´

ìˆ˜í–‰ì‹œê°„ì´ **5ms**ë¡œ ì¤„ì–´ë“ ë‹¤. (ëŒ€ë‹¤ìˆ˜ê°€ ì´ë ‡ê²Œ í’€ì´í•œë“¯?)

```java
class Solution {
    public String answerString(String word, int numFriends) {
        if (numFriends == 1) return word; // corner case

        // lex order first, desc length order then
        final int n = word.length();
        final int mxLen = word.length() - (numFriends-1);

        char mxChar = 'a';
        char[] wordArr = word.toCharArray();
        for (char ch : wordArr) mxChar = mxChar < ch ? ch : mxChar;

        String ans = "";
        for (int i = 0; i < n; ++i) {
            if (wordArr[i] != mxChar) continue;
            int j = Math.min(i+mxLen, n);
            String cand = word.substring(i, j);
            if (ans.compareTo(cand) < 0) ans = cand;
        }

        return ans;
    }
}
```

<br />

### ë©”ëª¨

- ì½”í…Œ ì—°ìŠµìš©ìœ¼ë¡œë„ ê´œì¶˜í•œë“¯
- corner case ë§ê³ ëŠ” ì „ë°˜ì ìœ¼ë¡œ ë¬´ë‚œí•œ ë‚œì´ë„
    - <span style={{fontSize: '32px', color: 'red'}}><b>ê¸°ë³¸ì ìœ¼ë¡œ ì…ë ¥ì˜ ìµœì†Œê°’ì€ ì¢€ í…ŒìŠ¤íŠ¸í•´ë³´ì‹­ì‡¼ ğŸ™‚...</b></span>