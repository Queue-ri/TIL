---
title: '2040 - Kth Smallest Product of Two Sorted Arrays'
eng_title: '2040 - Kth Smallest Product of Two Sorted Arrays'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '2040 - Kth Smallest Product of Two Sorted Arrays'
sidebar_position: 2040
created_date: 2025-06-25
updated_date: 2025-06-26
---

# 2040 - Kth Smallest Product of Two Sorted Arrays

:::info

- **ë¬¸ì œ ë³´ê¸°**: [2040 - Kth Smallest Product of Two Sorted Arrays](https://leetcode.com/problems/kth-smallest-product-of-two-sorted-arrays)
- **ì†Œìš” ì‹œê°„**: ğŸ’¥**1ì‹œê°„ ì´ˆê³¼**
- **í’€ì´ ì–¸ì–´**: `java`
- **ì²´ê° ë‚œì´ë„**: 4ï¸âƒ£
- **ë¦¬ë·° íšŸìˆ˜**: âœ…

:::

<br />

### í’€ì´ í‚¤ì›Œë“œ

<details>
<summary>ìŠ¤í¬ì£¼ì˜</summary>

`ì´ì§„íƒìƒ‰` `íˆ¬í¬ì¸í„°`

</details>

<br />

### í’€ì´ ì½”ë“œ

:::info

- **ë©”ëª¨ë¦¬**: 54840 KB
- **ì‹œê°„**: 211 ms

:::

```java
class Solution {
    public long kthSmallestProduct(int[] nums1, int[] nums2, long k) {
        /* 3 step solution */
        //    1. preprocess k with the total count of negative products
        //    2. start bsearch
        //    3. adjust search range via count of x which is leq than m

        List<Integer> anList = new ArrayList<>(); // a - negative
        List<Integer> apList = new ArrayList<>(); // a - positive
        List<Integer> bnList = new ArrayList<>(); // b - negative
        List<Integer> bpList = new ArrayList<>(); // b - positive

        separate(nums1, anList, apList);
        separate(nums2, bnList, bpList);

        long nProdCnt = (long)anList.size() * bpList.size() + (long)apList.size() * bnList.size();
        int sign = 1;
        List<Integer> a1 = anList;
        List<Integer> a2 = apList;
        List<Integer> b1, b2;

        if (k > nProdCnt) { // search pos
            k -= nProdCnt;
            b1 = bnList;
            b2 = bpList;
        }
        else { // search neg
            k = nProdCnt - k + 1;
            sign = -1;
            b1 = bpList;
            b2 = bnList;
        }

        // bsearch
        long l = 0, r = (long)1e10;
        while (l < r) {
            long m = (l + r) >> 1;
            if (cntLeqProd(a1, b1, m) + cntLeqProd(a2, b2, m) >= k) {
                r = m;
            }
            else {
                l = m + 1;
            }
        }

        return sign * l;
    }

    public void separate(int[] orig, List<Integer> neg, List<Integer> pos) {
        for (int n : orig) {
            if (n < 0) neg.add(-n); // abs
            else pos.add(n);
        }
        Collections.reverse(neg); // abs asc
    }

    public long cntLeqProd(List<Integer> a, List<Integer> b, long m) {
        long cnt = 0;
        int j = b.size() - 1; // reverse iteration (big -> small)

        // two-pointer optimization
        for (int n : a) {
            while (j > -1 && (long)n*b.get(j) > m) {
                --j; // need more smaller value
            }
            cnt += j + 1;
        }

        return cnt;
    }
}
```

<br />

### í’€ì´ í•´ì„¤

ë¬¸ì œ ë‚´ìš©ì€ a * b í–ˆì„ ë•Œ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ kë²ˆì§¸ product ê°’ì„ êµ¬í•˜ë¼ëŠ” êµ‰ì¥íˆ ì‹¬í”Œí•œ ìš”êµ¬ì‚¬í•­ì´ê³ 

a, b ë°°ì—´ ëª¨ë‘ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ëœ ìƒíƒœë¡œ ì£¼ê¸° ë•Œë¬¸ì— ì¹œì ˆí•œ ê²ƒ ê°™ì§€ë§Œ

ì‹¤ìƒì€ ì¡°ê±´ ì˜ ë‚˜ëˆ ì•¼ í•˜ëŠ”ë°ë‹¤ ì„±ëŠ¥ ìµœì í™”ê¹Œì§€ ê³ ë ¤í•´ì•¼ í•˜ëŠ” ê³ ë‚œì´ë„ ë¬¸ì œì´ë‹¤.

<br />

#### ğŸ§ ë‘ë‡Œë¥¼ í’€ê°€ë™í•´ìš”

WIP

<br />

### ë©”ëª¨

- 1ë²ˆì§¸ ìœ í˜•ì€ ë– ì˜¬ëëŠ”ë° êµ¬í˜„ ë°©í–¥ì„ ëª»ì¡ì•˜ê³  2ë²ˆì§¸ ìœ í˜•ì€ ìƒê° ëª»í–ˆìŒ
- ì—¬íƒœ ë³¸ 1ë²ˆì§¸ ìœ í˜• ë¬¸ì œ ì¤‘ ê°€ì¥ êµ¬í˜„ì´ ë³µì¡í•œë“¯
    - ìŒìˆ˜ ì²˜ë¦¬ë„ ë”°ë¡œ í•´ì•¼ í•˜ëŠ”... semi ë¹¡êµ¬í˜„ ìˆ˜ì¤€
- `cntLeqProd` ìµœì í™” ì•ˆí•˜ê³  ê·¸ëƒ¥ $O(n^2)$ ìŠ¤ìº”í•˜ë©´ TLE í„°ì§