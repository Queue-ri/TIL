---
title: '3459 - Length of Longest V-Shaped Diagonal Segment'
eng_title: '3459 - Length of Longest V-Shaped Diagonal Segment'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_label: '3459 - Length of Longest V-Shaped Diagonal Segment'
sidebar_position: 3459
created_date: 2025-08-28
---

# 3459 - Length of Longest V-Shaped Diagonal Segment

:::info

- **문제 보기**: [3459 - Length of Longest V-Shaped Diagonal Segment](https://leetcode.com/problems/length-of-longest-v-shaped-diagonal-segment)
- **소요 시간**: 47분 29초
- **풀이 언어**: `java`
- **체감 난이도**: 3️⃣~4️⃣ (3.7)
- **리뷰 횟수**: ✅

:::

<br />

### 풀이 키워드

<details>
<summary>스포주의</summary>

`DP`

</details>

<br />

### 풀이 코드

:::info

- **메모리**: 143900 KB
- **시간**: 424 ms

:::

```java showLineNumbers
class Solution {
    int[] dy = {-1, -1, 1, 1}; // lu, ru, rd, ld
    int[] dx = {-1, 1, 1, -1};

    int[][] grid;
    int n, m;

    int[][][][] memo;

    int dp(int y, int x, int dir, int turned) {
        //System.out.println("dp(" + y + ", " + x + ", " + dir + ", " + turned + ")");
        if ((y == 0 || y == n-1 || x == 0 || x == m-1) && turned == 1) return 1;
        if (memo[y][x][dir][turned] != 0) return memo[y][x][dir][turned];

        int res = 0;
        int curVal = grid[y][x];
        
        // no turn
        {
            int ny = y + dy[dir];
            int nx = x + dx[dir];
            // bound check
            if (0 <= ny && ny <= n-1 && 0 <= nx && nx <= m-1) {
                int nxtVal = grid[ny][nx];
                // value check
                if (nxtVal != 1 && nxtVal != curVal)
                    res = Math.max(res, dp(ny, nx, dir, turned));
            }
        }

        // turn
        if (turned == 0) {
            int nTurned = 1; // true
            int ndir = (dir + 1) % 4;
            int ny = y + dy[ndir];
            int nx = x + dx[ndir];
            // bound check
            if (0 <= ny && ny <= n-1 && 0 <= nx && nx <= m-1) {
                int nxtVal = grid[ny][nx];
                // value check
                if (nxtVal != 1 && nxtVal != curVal)
                    res = Math.max(res, dp(ny, nx, ndir, nTurned));
            }
        }

        //System.out.println("dp(" + y + ", " + x + ", " + dir + ", " + turned + ") = " + (res+1));
        return memo[y][x][dir][turned] = res + 1;
    }

    public int lenOfVDiagonal(int[][] grid) {
        this.grid = grid;
        n = grid.length;
        m = grid[0].length;
        memo = new int[n][m][4][2];

        int mx = 0;
        int self = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] != 1) continue;
                self = 1; // 1 exists

                for (int d = 0; d < 4; ++d) { // 4 directions
                    int ny = i + dy[d];
                    int nx = j + dx[d];
                    // bound check
                    if (0 <= ny && ny <= n-1 && 0 <= nx && nx <= m-1) {
                        // if matches the first number of the seq
                        if (grid[ny][nx] == 2)
                            mx = Math.max(mx, dp(ny, nx, d, 0));
                    }
                }
            }
        }

        return mx == 0 ? self : mx+1;
    }
}
```

<br />

### 풀이 해설

![](https://assets.leetcode.com/uploads/2025/01/11/length_of_longest3.jpg)

첫 칸은 1, 이후부턴 2, 0, 2, 0, ... 식으로 이어지며

진행방향은 대각선만 가능하고, 최대 딱 1번 시계방향 90도로 진행방향을 꺾을 수 있을 때

가장 길게 뽑을 수 있는 경로의 길이를 구하는 고차원 DP 문제이다.

<br />

### 🥲 실수 그마안~

처음엔 turn할 경우의 로직을 이렇게 설정했었고

```java {2} title="구버전 turn 로직"
// turn
if (turned == 0) {
    int nTurned = 1; // true
    int ndir = (dir + 1) % 4;
    int ny = y + dy[ndir];
    int nx = x + dx[ndir];
    ...
```

driver 단에선 초기 dp를 이렇게 호출하는 실수를 했다.

```java {3} title="구버전 driver 로직"
// if matches the first number of the seq
if (grid[ny][nx] == 2)
    mx = Math.max(mx, dp(i, j, d, 0));
```

즉, dp 첫 호출을 1이 쓰인 칸으로 넘겨버린 것이다.

그래서 return 단도 이러했다. (`mx`는 '1' 칸까지 합산된 값)

```java title="구버전 return 로직"
return mx == 0 ? self : mx;
```

:::note 구버전 코드와 전체 비교

import DeQrypter from '@site/src/components/mdx-crypto/DeQrypter';

<DeQrypter encrypted="U2FsdGVkX1+6lX4rgD7yt2ZMWAmoSOcOGkb9j/6xfpAdhUOVIgAr35ChwsE2ZIaefgAW4FGGiP1ujPPuKtSae+Br7ggoJssqjOgLEsbNasc=" />

:::

하지만 이는 다음의 케이스에서 얄짤없이 WA 걸렸는데

```java title="input"
[[2,0,2,0,2,0],
 [0,1,2,2,2,0],
 [2,0,1,0,2,0],
 [2,0,0,0,1,0],
 [0,0,2,0,2,0],
 [2,0,2,0,2,0],
 [2,0,2,0,2,0],
 [2,0,0,0,2,0]]
```

이게 왜 틀렸냐고? 디버깅을 해보자.

상단의 풀이 코드에서 해당 구버전 로직으로 수정 후, 주석 떼고 출력해보면 다음과 같다. (가독성을 위해 줄바꿈 넣음)

```java title="stdout"
dp(1, 1, 0, 0)

dp(0, 0, 0, 0)
dp(0, 0, 0, 0) = 1

dp(0, 2, 1, 1)
...
```

여기서 `dp(0, 2, 1, 1)`이 출력되었다는 점에서 조건이 잘못됨을 알 수 있다.

왜냐하면 (1, 1)은 시작점인데, 바로 다음 진행 칸인 (0, 2)에서 `turned`가 1(true) 일 수 없기 때문이다.

이는 방금 전 언급한, 하단의 라인에서 조건이 잘못되었기 때문이다.

```java {2}
// turn
if (turned == 0) {
    int nTurned = 1; // true
    int ndir = (dir + 1) % 4;
    int ny = y + dy[ndir];
    int nx = x + dx[ndir];
    ...
```

여기서 `turned == 0` 뿐만 아니라 `curVal != 1` 이라는 조건까지 추가되어야 AC를 받을 수 있다.

하지만 근본적으로는 driver 단에서 첫 dp 호출을 i, j로 넘겨버린 것이 원인이기 때문에,

최종 풀이코드는 다음의 3가지 수정을 거쳐 AC를 받았다.

- 첫 dp를 `ny`, `nx`로 넘김
- dp 내에서 조건을 `turned == 0`만 사용
- 최종 return 문에선 `mx`에 '1'칸이 합산되어있지 않으니 `mx+1`을 반환


<br />

### 메모

- <span style={{fontSize: '2rem'}}>**I ❤️ DP**</span>
- 그림만 보고 삼성st 빡구현인줄 알았는데 낚였다. 🎣
- GPT-5 mini thinking 모드에서 디버깅 못하고 뺑이치길래 답답해서 내가 함...