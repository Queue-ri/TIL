---
title: 'SSAFY CS 스터디: 3주차 리뷰'
sidebar_label: '⚔️ 이취컴 3주차 리뷰'
eng_title: 'SSAFY CS Study: Week 3 Review'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_position: 12
created_date: 2026-02-23
---

# SSAFY CS 스터디: 3주차 리뷰

:::info 리뷰 정보

- 범위: 이취컴 Chapter 03-1 ~ 03-4 (p.134~204)
- 참여형태: 🏹공격조

:::

<br />

---

🔮 **Chapter 03-1: 운영체제의 큰 그림**

---

### 운영체제의 두 가지 핵심 기능을 말씀해주세요.

<details>
<summary>답변</summary>

운영체제의 핵심 기능 2가지는 **자원 할당 및 관리**와 **프로세스 및 스레드 관리**입니다.<br />

*추가 질문: 자원 할당 및 관리로는 어떤 예시들이 있나요?*<br />
👉️ CPU 스케줄링, 가상 메모리, 파일 시스템 관리

</details>

<br />

### 프로세스와 스레드의 차이점을 말씀해주세요.

<details>
<summary>답변</summary>

프로세스는 실행 중인 프로그램이며, 스레드는 프로세스를 이루는 실행의 단위입니다.

</details>

<br />

### 커널 영역과 사용자 영역의 차이점을 말씀해주세요.

<details>
<summary>답변</summary>

커널 영역은 운영체제를 적재하여 실행하는 공간이고, 사용자 영역은 사용자 응용 프로그램이 적재되고 실행되는 공간입니다.

</details>

<br />

### 시스템 콜의 정의와 이것이 필요한 이유를 사용자 프로그램의 권한 관점에서 설명해주세요.

<details>
<summary>답변</summary>

시스템 콜은 응용 프로그램이 운영체제의 서비스를 제공받기 위해 호출하는 인터페이스입니다.<br />
응용 프로그램이 하드웨어나 민감한 자원에 직접 접근하면 시스템 전체의 안전을 해칠 수 있으므로,<br />
권한이 제한된 사용자 모드에서 실행되다가, 자원 접근이 필요할 때 시스템 콜을 통해 커널 모드로 전환하여 안전하게 실행하도록 하는 것입니다.

</details>

<br />

### CPU의 이중 모드인 사용자 모드와 커널 모드의 차이점을 설명해주세요.

<details>
<summary>답변</summary>

- **사용자 모드:** 응용 프로그램이 실행되는 모드로, 자원에 접근하는 명령어를 실행할 수 없습니다.
- **커널 모드**: 운영체제 코드가 실행되는 모드로, CPU가 모든 자원에 접근하고 명령어를 실행할 수 있습니다.

*추가 질문: CPU는 현재 모드가 무엇인지 어떻게 구분하나요?*<br />
👉️ CPU는 플래그 레지스터 속의 슈퍼바이저 플래그를 통해 현재 어떤 모드인지 구분하여 시스템을 보호합니다.

</details>

<br />

### 시스템 콜이 호출되었을 때, CPU에서 일어나는 과정을 요약해주세요.

<details>
<summary>답변</summary>

1. 사용자 프로그램이 시스템 콜을 호출하여 소프트웨어 인터럽트를 발생시킵니다.
2. CPU는 현재 작업을 백업하고 사용자 모드에서 커널 모드로 전환합니다.
3. 커널 영역의 시스템 콜 서비스 루틴을 실행하여 요청된 작업을 수행합니다.
4. 작업 완료 후 사용자 모드로 복귀하여 응용 프로그램 실행을 재개합니다.

</details>

<br />

---

🔮 **Chapter 03-2: 프로세스와 스레드**

---

### 프로세스의 메모리 영역 구조를 각각 설명해주세요.

<details>
<summary>답변</summary>

- 코드 영역(=텍스트 영역): 실행할 명령어 저장, read-only 영역
- 데이터 영역: **초기값이 있는** 전역변수, 정적변수를 저장 (프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간)
- BSS 영역: **초기값이 없는** 데이터를 저장 (프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간)
- 힙 영역: 개발자가 직접 할당하는 공간. 반환하지 않으면 메모리 누수 문제 발생.
- 스택 영역: 함수 매개변수, 지역 변수, 함수 복귀 주소 저장 (일시적으로 사용할 값을 저장하는 공간)

*추가 질문: 왜 이렇게 분리하여 관리해야 할까요?*<br />
👉️ 영역을 분리함으로써 코드와 같은 읽기 전용 데이터를 보호하고,<br />
실행 중 크기가 변하는 동적 할당 영역(힙, 스택)과 정적 할당 영역(코드, 데이터)을 구분하여 메모리를 효율적으로 관리할 수 있기 때문입니다.

</details>

<br />

### PCB가 무엇인지 설명하고, 어디에 어떤 형태로 관리되는지, 어떤 정보를 담고 있는지 설명해주세요.

<details>
<summary>답변</summary>

PCB는 운영체제가 프로세스를 식별하고 관리하기 위해 필요한 정보를 담은 구조체입니다.<br />
프로세스가 생성될 때 커널 영역에 만들어지며, 프로세스 테이블 형태로 관리됩니다.<br />
PID, 레지스터값, 프로세스 상태, CPU 스케줄링(우선순위) 정보, 메모리 적재 위치, 프로세스가 사용한 파일 및 입출력장치 정보 등을 담고 있습니다.
</details>

<br />

### PCB와 관련하여 좀비 프로세스가 무엇인지 말씀해주세요.

<details>
<summary>답변</summary>

프로세스가 비정상 종료되어 자원은 회수되었으나, 프로세스 테이블에 PCB가 남은 상태를 **좀비 프로세스**라고 합니다.

</details>

<br />

### 문맥 교환의 정의와 이 과정에서 발생하는 오버헤드에 대해 설명해주세요.

<details>
<summary>답변</summary>

문맥 교환은 실행 중인 프로세스의 상태(문맥)를 PCB에 백업하고, PCB에서 새 프로세스의 문맥을 복구하여 실행하는 과정입니다.<br />
너무 잦은 문맥 교환이 발생하면 교환에 드는 오버헤드 및 캐시 미스 증가로 인한 오버헤드가 발생합니다.

</details>

<br />

### 프로세스의 5가지 상태를 각각 간략히 설명해주세요.

<details>
<summary>답변</summary>

- 생성(new): 메모리에 적재되어 PCB를 할당받은 상태
- 준비(ready): CPU 할당을 대기중인 상태
- 실행(running): CPU를 할당받아 실행중인 상태
    - dispatch: 준비 상태에서 실행 상태로 전환되는 것
    - 타이머 인터럽트 발생 시 준비 상태가 됨
- 대기(blocked): 입출력 작업 요청, 바로 확보할 수 없는 자원 요청 시
    - 입출력 작업 완료 시 준비 상태가 됨
- 종료(terminated): 프로세스가 종료된 상태. PCB와 사용된 메모리가 정리됨.

</details>

<br />

### 프로세스의 5가지 상태 중 대기 상태와 준비 상태의 차이는 무엇인가요?

<details>
<summary>답변</summary>

준비 상태는 CPU만 할당받으면 즉시 실행 가능한 상태이지만,<br />
대기 상태는 입출력 작업이나 특정 이벤트가 완료될 때까지 기다리는 상태로, CPU를 할당받아도 당장 실행할 수 없는 상태라는 점이 다릅니다.

</details>

<br />

### 멀티프로세스와 멀티스레드의 가장 큰 차이점은 무엇인가요?

<details>
<summary>답변</summary>

가장 큰 차이점은 자원 공유 여부입니다.<br />
멀티프로세스는 각 프로세스가 독립된 메모리 공간을 가지기 때문에 자원을 공유하지 않지만,<br />
멀티스레드는 프로세스 자원인 힙, 데이터, 코드 영역을 공유하고, 각각은 개별적인 스택과 레지스터 값만 가집니다.<br />
따라서 스레드는 통신 비용이 적고 효율적이지만, 하나의 스레드 문제가 프로세스 전체에 영향을 줄 수 있다는 단점이 있습니다.

</details>

<br />

### IPC(프로세스 간 통신)의 대표적인 방식 두 가지를 비교해서 설명해주세요.

<details>
<summary>답변</summary>

- **공유 메모리**: 두 프로세스가 공통의 메모리 영역을 사용. 통신 속도가 빠르지만, 데이터 일관성 문제(Race Condition)가 발생할 수 있습니다.
- **메시지 전달**: 커널을 거쳐 데이터를 주고받음. 통신 속도가 느리지만, 커널이 동기화를 제어하므로 더 안전하다는 특징이 있습니다.

</details>

<br />

### IPC 중 메시지 전달 방식의 대표적인 예시를 간략히 설명해주세요.

<details>
<summary>답변</summary>

- 파이프: 단방향 프로세스 통신 도구
- 시그널: 프로세스에게 특정 이벤트가 발생했음을 알리는 비동기 신호
- RPC: 원격 코드를 실행하는 기술
- 소켓

*추가 질문: 익명 파이프와 네임드 파이프의 차이점을 말씀해주세요.*<br />
👉️ 익명 파이프는 양방향 통신을 지원하지 않고, 부모 프로세스와 자식 프로세스 간에만 통신이 가능합니다.<br />
네임드 파이프는 양방향 통신을 지원하며, 임의의 프로세스 간에도 통신이 가능합니다.

</details>

<br />

---

🔮 **Chapter 03-3: 동기화와 교착 상태**

---

### 공유 자원과 임계 구역의 개념 및 발생할 수 있는 문제에 대해 설명해주세요.

<details>
<summary>답변</summary>

공유 자원은 프로세스나 스레드가 공동으로 이용하는 메모리, 파일, 변수 등을 의미하며,<br />
이 공유 자원에 접근하는 코드 영역 중 동시에 실행했을 때 문제가 발생할 수 있는 영역을 임계 구역이라고 합니다.<br />
여러 프로세스/스레드가 동시에 임계 구역에 진입하면 실행 순서에 따라 결과가 달라지는 **Race Condition**이 발생하여 데이터의 일관성이 깨질 수 있습니다.

</details>

<br />

### Race Condition 이란 무엇이며, 이를 방지하기 위한 동기화의 2가지 조건을 설명해주세요.

<details>
<summary>답변</summary>

Race Condition은 두 개 이상의 프로세스나 스레드가 공유 자원을 동시에 수정할 때, 실행 순서에 따라 결과가 비정상적으로 달라지는 현상입니다.<br />
이를 방지하려면 다음 두 조건을 충족해야 합니다.

1. 실행 순서 제어: 프로세스/스레드를 올바른 순서대로 실행하기
2. 상호 배제(Mutex): 한 프로세스가 임계 구역에서 작업 중이면 다른 프로세스는 진입할 수 없도록 격리하기

</details>

<br />

### Mutex Lock의 동작 원리와 주요 함수의 역할에 대해 설명해주세요.

<details>
<summary>답변</summary>

뮤텍스 락은 하나의 자원에 대해 하나의 프로세스만 접근할 수 있도록 보장하는 동기화 도구입니다.

- `acquire()`: 임계 구역 진입 전 호출하며, 락이 걸려 있다면 해제될 때까지 대기하고, 비어 있다면 락을 획득합니다.
- `release()`: 임계 구역 작업 종료 후 호출하며, 획득한 락을 해제하여 대기 중인 다른 프로세스가 진입할 수 있게 합니다.

</details>

<br />

### 세마포어가 뮤텍스 락과 다른 점은 무엇이며, 어떻게 여러 자원을 관리하나요?

<details>
<summary>답변</summary>

뮤텍스 락은 하나의 공유 자원을 대상으로 하지만, 세마포어는 공유 자원이 여러 개 있는 상황에서도 사용 가능한 범용적인 동기화 도구입니다.<br />
세마포어는 사용 가능한 자원의 개수를 나타내는 변수 S를 사용합니다.<br />
`wait()` 함수는 자원 개수를 확인하고 감소시키며 진입을 시도하고, 자원이 없으면 대기 상태로 만듭니다.<br />
`signal()` 함수는 작업을 마친 후 자원을 반납하고 대기 중인 프로세스를 깨우는 역할을 합니다.

</details>

<br />

### 세마포어에서 대기 중인 프로세스를 관리하는 방식에 대해 설명해주세요.

<details>
<summary>답변</summary>

사용할 자원이 없을 때 프로세스는 단순히 무한 루프를 돌며 기다리는 '바쁜 대기'를 하지 않고, `sleep()`을 호출해 대기 상태로 전환됩니다.<br />
이후 다른 프로세스가 자원을 반납하며 `wakeup()`을 호출하면, 대기 상태에 있던 프로세스가 준비 상태로 바뀌어 다시 실행 기회를 얻게 됩니다.

</details>

<br />

### 세마포어의 기본 원리와 이진 세마포어, 카운팅 세마포어의 차이점에 대해 설명해주세요.

<details>
<summary>답변</summary>

세마포어는 공유 자원의 개수를 나타내는 변수를 통해 여러 프로세스나 스레드의 접근을 제어하는 동기화 도구입니다.

- **이진 세마포어**: 값이 0과 1만 가질 수 있어 뮤텍스와 유사하게 상호 배제를 목적으로 사용됩니다.
- **카운팅 세마포어**: 자원이 여러 개일 때 사용하며, 사용 가능한 자원의 개수만큼 값을 가질 수 있어 다수의 프로세스가 동시에 접근하는 것을 관리합니다.

</details>

<br />

### 조건 변수에서 `wait()`과 `signal()` 함수는 각각 어떤 역할을 수행하나요?

<details>
<summary>답변</summary>

조건 변수는 특정 조건이 충족될 때까지 프로세스를 대기시키거나 실행을 재개하는 동기화 도구입니다.<br />

- `wait()`: 호출한 프로세스를 대기 상태로 전환하며 점유하던 뮤텍스를 반납합니다.
- `signal()`: 조건이 충족되었음을 알리며, 대기 상태에 있던 프로세스 중 하나를 깨워 실행을 재개시킵니다.

</details>

<br />

### 모니터 동기화 기법이 뮤텍스나 세마포어에 비해 가지는 강점은 무엇인가요?

<details>
<summary>답변</summary>

모니터는 공유 자원과 그 자원을 다루는 인터페이스(함수)를 하나의 묶음으로 관리하는 동기화 도구입니다.<br />
모니터 내부에 진입할 수 있는 프로세스는 한 번에 하나로 제한되어 상호 배제가 자동으로 보장됩니다.<br />
사용자가 직접 세마포의 P/V 연산을 관리할 필요 없이 인터페이스 호출만으로 안전하게 자원을 사용할 수 있어 실수를 줄여줍니다.

</details>

<br />

### Thread Safety란 무엇이며, 자바의 Vector와 ArrayList 중 어느 것이 더 안전한지 이유와 함께 설명해주세요.

<details>
<summary>답변</summary>

스레드 안전이란 멀티스레드 환경에서 여러 스레드가 동시에 데이터에 접근하더라도 실행 결과가 항상 올바르게 유지되는 상태를 의미합니다.<br />
Vector는 내부 메서드에 `synchronized` 키워드가 적용되어 있어 스레드 안전하지만,<br />
ArrayList는 동기화 처리가 되어 있지 않아 여러 스레드가 동시에 데이터를 추가할 경우 데이터 손실이나 오류가 발생하는 Race Condition의 우려가 있습니다.

</details>

<br />

### 교착 상태가 발생하기 위한 4가지 필수 조건에 대해 설명해주세요.

<details>
<summary>답변</summary>

교착 상태는 다음 4가지 조건이 **모두 만족될 때** 발생할 가능성이 생깁니다.

1. **상호 배제**: 한 번에 한 프로세스만 자원을 사용할 수 있음
2. **점유와 대기**: 자원을 가진 채 다른 자원을 기다림
3. **비선점**: 다른 프로세스의 자원을 강제로 뺏을 수 없음
4. **원형 대기**: 프로세스들이 서로의 자원을 꼬리에 꼬리를 물고 기다림

</details>

<br />

### 교착 상태 해결 방법 중 '교착 상태 회피'가 무엇이고, 대표적인 알고리즘은 어떤 것이 있나요?

<details>
<summary>답변</summary>

교착 상태 회피는 자원 할당 시 발생할 수 있는 잠재적 교착 상태 가능성을 검토하여, 시스템을 '안전 상태'로 유지할 수 있을 때만 자원을 할당하는 방식입니다.<br />
자원의 배분 상태를 미리 파악하여 할당하며, 대표적인 알고리즘으로는 **은행원 알고리즘**이 있습니다.

</details>

<br />

---

🔮 **Chapter 03-4: CPU 스케줄링**

---

### CPU burst와 I/O burst의 개념을 설명하고, 왜 운영체제가 이 두 프로세스 유형을 구분하여 스케줄링해야 하는지 설명해주세요.

<details>
<summary>답변</summary>

CPU burst는 프로세스가 연산을 수행하는 시간이며, I/O burst는 입출력 장치를 기다리는 시간입니다.<br />
입출력 집중 프로세스는 짧은 CPU burst를 자주 사용하므로,<br />
이들의 우선순위를 높여 빨리 처리하고 다시 I/O 대기 상태로 보내는 것이<br />
전체적인 CPU 활용률과 시스템 반응성을 높이는데 유리하기 때문에 구분하여 스케줄링합니다.

</details>

<br />

### 선점형 스케줄링과 비선점형 스케줄링의 차이점과 각각의 장단점을 설명해주세요.

<details>
<summary>답변</summary>

선점형은 OS가 실행 중인 프로세스의 자원을 강제로 뺏을 수 있는 방식이고, 비선점형은 프로세스가 CPU를 반납할 때까지 기다리는 방식입니다.<br />
선점형은 빠른 응답성을 보장해 현대 OS에 적합하지만 문맥 교환 오버헤드가 발생하며,<br />
비선점형은 오버헤드는 적지만 특정 프로세스가 CPU를 독점할 경우 시스템 전체가 멈춘 듯한 '응답 없음' 현상이 발생할 수 있습니다.

</details>

<br />

### FCFS 스케줄링에서 발생할 수 있는 호위 효과란 무엇이며, 이를 어떻게 해결할 수 있나요?

<details>
<summary>답변</summary>

호위 효과란 실행 시간이 매우 긴 프로세스가 먼저 도착하여, 뒤에 있는 짧은 프로세스들의 대기 시간이 비정상적으로 길어지는 현상입니다.<br />
이를 해결하기 위해 실행 시간이 짧은 프로세스를 먼저 처리하는 SJF 방식이나, 일정 시간만 사용하고 넘기는 라운드 로빈 방식을 사용할 수 있습니다.

</details>

<br />

### 라운드 로빈 스케줄링에서 타임 슬라이스의 크기가 시스템 성능에 미치는 영향에 대해 설명해주세요.

<details>
<summary>답변</summary>

타임 슬라이스가 너무 크면 사실상 FCFS와 다를 바 없어져 응답성이 떨어집니다.<br />
반대로 너무 작으면 빈번한 문맥 교환으로 인해 CPU가 실제 작업보다 스케줄링 자체에 더 많은 자원을 소모하는 오버헤드가 발생합니다.<br />
따라서 적절한 크기를 설정하는 것이 중요합니다.

</details>

<br />

### 우선순위 스케줄링의 치명적인 단점인 기아 현상과 이를 해결하기 위한 에이징 기법에 대해 설명해주세요.

<details>
<summary>답변</summary>

기아 현상은 우선순위가 낮은 프로세스가 상위 우선순위 프로세스에 밀려 무한정 대기하는 현상입니다.<br />
에이징 기법은 오랫동안 대기한 프로세스의 우선순위를 점진적으로 높여서, 언젠가는 반드시 실행될 수 있도록 보장합니다.

</details>

<br />

### 다단계 피드백 큐가 현대 운영체제에서 가장 일반적인 알고리즘으로 꼽히는 이유를 설명해주세요.

<details>
<summary>답변</summary>

MLFQ는 프로세스가 CPU를 많이 사용하면 우선순위가 낮은 큐로 이동시키고,<br />
입출력이 잦으면 높은 우선순위 큐에 유지함으로써 I/O 집중 프로세스를 우대합니다.<br />
또한 낮은 우선순위 큐에서 오래 기다린 프로세스를 에이징으로 격상시켜 기아 현상을 방지합니다.<br />
이처럼 프로세스의 특성을 동적으로 파악해 반응성과 효율성을 동시에 고려하므로 일반적으로 사용됩니다.

</details>

<br />

### 리눅스의 CFS 알고리즘에서 사용되는 vruntime의 개념과 이것이 스케줄링에 어떻게 활용되는지 설명해주세요.

<details>
<summary>답변</summary>

vruntime은 프로세스가 실제로 실행된 시간에 가중치(우선순위)를 반영한 가상 시간입니다.<br />
리눅스는 이 vruntime 값이 가장 작은 프로세스를 다음에 실행할 대상으로 선택합니다.<br />
이를 통해 우선순위가 높은 프로세스는 vruntime이 천천히 증가하여 더 자주 CPU를 할당받게 함으로써 공평한 자원 배분을 실현합니다.

</details>