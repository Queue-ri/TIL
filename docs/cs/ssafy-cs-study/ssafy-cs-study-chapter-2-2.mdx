---
title: 'SSAFY CS 스터디: 이취컴 Chapter 2-2 정리'
sidebar_label: '이취컴 Chapter 2-2 정리'
eng_title: 'SSAFY CS Study: Chapter 2-2 Summary'
image: https://til.qriosity.dev/img/m_banner_background.jpg
sidebar_position: 2
created_date: 2026-02-02
updated_date: 2026-02-02
---

# SSAFY CS 스터디: 이취컴 Chapter 2-2 정리

:::info Chapter 02 컴퓨터 구조 - 2 컴퓨터가 이해하는 정보

p.45~65

:::

<br />

---

### 프로그램 관점의 정보 단위

비트: 0과 1을 나타내는 가장 작은 정보의 단위
- $n$비트는 $2^n$개의 정보 표현 가능

:::info 단위의 차이

1000개씩 묶어서 KB, MB, GB, TB로 올라가고<br />
1024개씩 묶어서 KiB, MiB, GiB, TiB로 올라감 (아니 여기도 오타가)

:::

### CPU 관점의 정보 단위

워드: CPU가 한 번에 처리할 수 있는 정보의 크기<br />
- 현대는 보통 1워드가 4바이트(32비트), 8바이트(64비트)

---

<br />

### 데이터 - 0과 1로 숫자 표현하기

2진수의 단점.. 너무 길어서 16진수를 보조적으로 널리 사용한다.

:::warning 16진수 사용처

MAC 주소, IPv6 주소 등

:::

#### 부동 소수점 오차

부동 소수점: 소수점이 고정되지 않은 소수 표현법. 필요에 따라 소수점 위치를 옮길 수 있다.<br />
$123.123$을 $m \times 10^n$ 형태로 표현하면, $1.23123 \times 10^2$도 되고 $1231.23 \times 10^{-1}$도 된다.<br />
여기서 `2`와 `-1`이 지수(exponent), `1.23123`과 `1231.23`이 가수(mantissa, significand)이다.

2진수 체계에선 $m \times 2^n$ 형태로 표현한다.<br />
10진수 체계에서 1/3이 0.3333... 무한소수가 되는 것처럼, 2진수 체계에서도 정확히 표현되지 않는 소수가 존재한다.<br />
하지만 컴퓨터 메모리는 한정되어 있으므로 여기서 일부 생략되기에 오차가 발생한다.

#### IEEE 754

![](https://velog.velcdn.com/images/qriosity/post/cb763678-db81-4967-95cc-22cb1e175ca3/image.png)

- float(32비트): 1 - 8 - 23비트
- double(64비트): 1 - 11 - 52비트
- 부호 비트는 1이면 음수
- 가수는 1.xx로 정규화해서 앞에 1 떼고 소수부분인 .xx에 해당하는 데이터만 저장된다.
    - `1101011.1010101`은 `1.1010111010101 x 2^6`로 정규화해서 xx 부분인 `1010111010101`만 저장
- 지수는 bias값 더해서 저장. bias는 지수 표현에 사용되는 비트 수가 $n$일 때 $2^n-1$
    - 1.xx $\times 2^6$ 형태의 데이터에서 bias는 32비트 표현시 $2^8-1$, 64비트는 $2^{11}-1$
    - 32비트 표현시 저장되는 지수는 최종 $(2^8-1) + 6 = 133$

<br />

### 데이터 - 0과 1로 문자 표현하기

문자 집합: 컴퓨터가 이해할 수 있는 문자들의 집합
    - ASCII, EUC-KR, UTF-8 등

문자 인코딩: 문자 집합을 0과 1의 문자 코드로 변환하는 과정<br />
문자 디코딩: 0과 1의 문자 코드를 사람이 이해하는 문자로 변환하는 과정

#### ASCII

- 영문, 아라비아 숫자, 일부 특수문자
- 8비트(1바이트)
    - 패리티 비트(1비트) + 문자 표현 비트(7비트) -> 128개 문자 표현 가능

:::info 코드 포인트

문자 인코딩에서 각 문자에 부여된 고유값을 코드 포인트라고 한다.
- 아스키 문자 `A`의 코드 포인트는 65, `a`는 97, `0`은 48, `Space`는 32

:::

#### EUC-KR

- 아스키 문자를 표현할때 1바이트, 한글 문자를 표현할때 2바이트 사용

#### 유니코드

- 전 세계 모든 문자를 표현하기 위한 표준
- 더 많은 언어, 특수문자, 이모티콘 표현 가능
- UTF-8, UTF-16은 가변 길이 인코딩 방식, UTF-32는 고정 길이 인코딩 방식

:::info 유쁠러스의 정체

U+AE00 처럼 앞에 붙는 U+는 16진수 표기법을 나타내는 접두사이다.

:::

#### base64

문자뿐만 아니라 이진 데이터까지 변환 가능한 64진법 인코딩 방식 (이진 데이터에 더 많이 이용됨)<br />
이미지 등 이진 데이터를 아스키 문자 형태로 표현 가능<br />
16비트가 이진수로 0000과 같이 4자리이므로 64비트인 **base64는 6자리 단위로 인코딩됨**

Ex. `abc`<br />
👉️ 01100001 01100010 01100011 (24비트)<br />
👉️ 011000 010110 001001 100011 (6비트 단위로 분할)<br />
👉️ 각 6비트에 해당하는 base64 문자로 매핑<br />
👉️ `YWJj`

:::info 6의 배수 길이가 아니면요?

ab 같이 이진수로 8자리면 4자리가 모자르다. 이땐 0으로 패딩하고 6비트 단위로 쪼갠다.<br />
0으로 남아도는 부분은 흔히 보았을 `=`로 인코딩된다.

:::

<br />

### 명령어

명령어 = 수행할 동작(**연산 코드, 연산자, opcode**) + **0개 이상**의 수행할 대상(**피연산자, operand**)

피연산자는 데이터 자체이거나 데이터가 저장된 위치가 될 수 있다.

명령어에서 연산자가 담기는 영역을 operation field, 피연산자가 담기는 영역을 operand field라고 한다.

피연산자는 대부분 직접적인 데이터 명시보단 데이터가 저장된 위치인 메모리 주소나 레지스터명이 쓰인다.<br />
👉️ operand field를 **주소 필드**라고도 하는 이유!

#### 대표적인 연산자 유형

- 데이터 전송: `LOAD`, `STORE`, `MOV`
- 산술/논리 연산: `ADD`, `SUB`, `AND`, `OR`, `NOT`, `CMP`
- 제어 흐름 변경: `HALT`, `JMP`, `CALL`, `RET`
- 입출력 제어: `READ`, `WRITE`, `IN`, `OUT`

#### 기계어와 어셈블리어

기계어를 읽기 편한 형태로 단순 번역한 것이 어셈블리어

#### 명령어 사이클

CPU가 명령어를 처리하는 과정

1. **인출 사이클**(fetch): 메모리에서 명령어를 읽어옴
2. **실행 사이클**(execute): 명령어를 해석하고 실행

이거 무한 반복... 근데 인출과 실행 사이에 **간접 사이클**이 끼어들기도 함

:::info 간접 사이클(indirect)

오퍼랜드 필드에 주소가 들어있다면 실행 전 또다시 메모리 접근을 해야 한다. 이 접근 단계를 간접 사이클이라고 한다.

:::

:::danger 짱중요한 **인터럽트 사이클**도 있어용

이건 Chapter 2-3에서 다룸

:::